类间关联

1. 贼(Thief)偷窃行人，每个行人都有随身带的钱，贼偷窃一个行人，他的钱就增加相应的钱包里的钱数。
   请给出Thief类和Walker类。
   
2. 警察局有多名警察，每个警察抓获一名贼，警察局的声望就增加1点，该警察的奖金就增加100元，贼的金钱减为0。
   
   请实现相关的警察局、警察、贼的类。
   
   用例可为：警察局S有警察p1,p2,p3,贼有t1,t2,t3,t4, p1抓获t2,t3,   p2抓获t4,  p3没抓获任何贼。t1的初始金钱为500，
   t2的初始金钱为800，t3的初始金钱为300，t4的初始金钱为1000，S的初始声望为100，警察的初始奖金为0。
   输出最终S的声望，每个警察的奖金数。
   
3. 在2的基础上，再加上1中的类，试一试。


4.一个驯马游戏有如下描述：

游戏里有多个英雄(Hero),玩家可以选择其中一个并扮演它,每个英雄有自己的生命力(hitpoint),法力(power)；

游戏中还有马（Horse),每匹马有自己的生命力(hitpoint),攻击力(damage),防御力(defense),速度(speed)。

每个英雄至多可有一匹马作为英雄的坐骑(saddle），初始时，英雄没有坐骑；英雄可以指定某匹马为坐骑。

英雄和其坐骑一起要经常与其它马发生战斗。若失败，则失去原有的坐骑。

战斗中，由英雄一方先发起攻击，然后马再攻击英雄及其坐骑，之后英雄一方再攻击，之后马再攻击英雄一方，。。。。，直到一方胜利。
战斗中，若英雄的生命力减少至0，则英雄失败；若英雄坐骑的生命力减少至0，则英雄一方失败且失去坐骑；若马的生命力减少至0，则表示英雄一方胜利。


英雄每胜利一次，英雄的生命力增加10；
英雄每失败一次，英雄的法力减少1级，至多减少至1级；
无论胜利与失败，战斗后，英雄的其它属性值、坐骑、马的属性值，全部恢复。

战斗的算法表示如下：
英雄一方攻击马，给马造成的伤害(马的生命力减少值)为：坐骑造成的伤害 + 英雄造成的伤害    
    坐骑造成的伤害为：坐骑的攻击力*(坐骑的速度+英雄的法力) - 马的防御力*马的速度，且值若小于1，则取1
    英雄造成的伤害：  英雄的法力*20
    
马攻击英雄一方，给英雄一方造成的伤害为：
    给英雄和坐骑各造成的伤害:  马的攻击力*马的速度 - 坐骑的防御力*坐骑的速度，且值若小于1，则取1
   

根据上述描述，定义相应的类，并给出具体实现，最后给出测试用的main函数。

5.用简单双向关联和关联类的形式分别实现男人(Man)和女人(Woman)间的一对一关系。
  一个未婚男人可以和一个未婚女人结婚；
  一个已婚男人可以其妻子离婚；
  一个未婚女人可以和一个未婚男人结婚；
  一个已婚女人可以其丈夫离婚；
  一个已婚男人可以“知道”其妻子； 
  一个已婚女人可以“知道”其丈夫；

6.现有类A和类B

class A {
public:
	A(int num):mData(num){    }
	~A( ) {    }
	int GetData( ) const    { return mData; } 
	void SetData(int data)  { mData = data; }
private:
	int mData;
};

class B {
public:
      	B(int num=0):pa(new A(num)) {  }
     	~B( ) {delete pa;}
      	B(const B& rhs) {
             pa=new A(*rhs.pa);
       	}
      	B& operator=(const B& rhs)  {
		if ( this!=&rhs )  {
                 	delete pa;
 	                pa=new A(*rhs.pa); 
         	}
		return *this;
	}
     	A* operator->( ) const {return pa;}
	void GetData() const   { return pa->GetData();}
	void SetData(int data) { pa->SetData(data); }
private:
 	A*	pa;
};

a）现需要以引用计数的方法，重新实现类B，要求类A不得做任何修改。
b）请在a）的基础上，以Copy On Write的方式修改类B的实现，
   使得B类对象可以访问成员B类的成员SetData(int);(即可以修改
   Ｂ类对象中pa指针指向的A类对象的数据成员。也就是说，使用B类对象时，
   对于以只读方式访问A类的成员，使用引用计数；
   对于以写方式访问A类的成员，要先进行深赋值，然后再写数据)。

