     1                                           ;代码清单15-1
     2                                           ;文件名：c15_core.asm
     3                                           ;文件说明：保护模式微型核心程序 
     4                                           ;创建日期：2011-11-19 21:40
     5                                  
     6                                           ;以下常量定义部分。内核的大部分内容都应当固定 
     7                                           core_code_seg_sel     equ  0x38    ;内核代码段选择子
     8                                           core_data_seg_sel     equ  0x30    ;内核数据段选择子 
     9                                           sys_routine_seg_sel   equ  0x28    ;系统公共例程代码段的选择子 
    10                                           video_ram_seg_sel     equ  0x20    ;视频显示缓冲区的段选择子
    11                                           core_stack_seg_sel    equ  0x18    ;内核堆栈段选择子
    12                                           mem_0_4_gb_seg_sel    equ  0x08    ;整个0-4GB内存的段的选择子
    13                                  
    14                                  ;-------------------------------------------------------------------------------
    15                                           ;以下是系统核心的头部，用于加载核心程序 
    16 00000000 [00000000]                       core_length      dd core_end       ;核心程序总长度#00
    17                                  
    18 00000004 [00000000]                       sys_routine_seg  dd section.sys_routine.start
    19                                                                              ;系统公用例程段位置#04
    20                                  
    21 00000008 [00000000]                       core_data_seg    dd section.core_data.start
    22                                                                              ;核心数据段位置#08
    23                                  
    24 0000000C [00000000]                       core_code_seg    dd section.core_code.start
    25                                                                              ;核心代码段位置#0c
    26                                  
    27                                  
    28 00000010 [E5030000]                       core_entry       dd start          ;核心代码段入口点#10
    29 00000014 3800                                              dw core_code_seg_sel
    30                                  
    31                                  ;===============================================================================
    32                                           [bits 32]
    33                                  ;===============================================================================
    34                                  SECTION sys_routine vstart=0                ;系统公共例程代码段 
    35                                  ;-------------------------------------------------------------------------------
    36                                           ;字符串显示例程
    37                                  put_string:                                 ;显示0终止的字符串并移动光标 
    38                                                                              ;输入：DS:EBX=串地址
    39 00000000 51                               push ecx
    40                                    .getc:
    41 00000001 8A0B                             mov cl,[ebx]
    42 00000003 08C9                             or cl,cl
    43 00000005 7408                             jz .exit
    44 00000007 E805000000                       call put_char
    45 0000000C 43                               inc ebx
    46 0000000D EBF2                             jmp .getc
    47                                  
    48                                    .exit:
    49 0000000F 59                               pop ecx
    50 00000010 CB                               retf                               ;段间返回
    51                                  
    52                                  ;-------------------------------------------------------------------------------
    53                                  put_char:                                   ;在当前光标处显示一个字符,并推进
    54                                                                              ;光标。仅用于段内调用 
    55                                                                              ;输入：CL=字符ASCII码 
    56 00000011 60                               pushad
    57                                  
    58                                           ;以下取当前光标位置
    59 00000012 66BAD403                         mov dx,0x3d4
    60 00000016 B00E                             mov al,0x0e
    61 00000018 EE                               out dx,al
    62 00000019 6642                             inc dx                             ;0x3d5
    63 0000001B EC                               in al,dx                           ;高字
    64 0000001C 88C4                             mov ah,al
    65                                  
    66 0000001E 664A                             dec dx                             ;0x3d4
    67 00000020 B00F                             mov al,0x0f
    68 00000022 EE                               out dx,al
    69 00000023 6642                             inc dx                             ;0x3d5
    70 00000025 EC                               in al,dx                           ;低字
    71 00000026 6689C3                           mov bx,ax                          ;BX=代表光标位置的16位数
    72                                  
    73 00000029 80F90D                           cmp cl,0x0d                        ;回车符？
    74 0000002C 750E                             jnz .put_0a
    75 0000002E 6689D8                           mov ax,bx
    76 00000031 B350                             mov bl,80
    77 00000033 F6F3                             div bl
    78 00000035 F6E3                             mul bl
    79 00000037 6689C3                           mov bx,ax
    80 0000003A EB60                             jmp .set_cursor
    81                                  
    82                                    .put_0a:
    83 0000003C 80F90A                           cmp cl,0x0a                        ;换行符？
    84 0000003F 7506                             jnz .put_other
    85 00000041 6683C350                         add bx,80
    86 00000045 EB15                             jmp .roll_screen
    87                                  
    88                                    .put_other:                               ;正常显示字符
    89 00000047 06                               push es
    90 00000048 B820000000                       mov eax,video_ram_seg_sel          ;0xb8000段的选择子
    91 0000004D 8EC0                             mov es,eax
    92 0000004F 66D1E3                           shl bx,1
    93 00000052 2667880F                         mov [es:bx],cl
    94 00000056 07                               pop es
    95                                  
    96                                           ;以下将光标位置推进一个字符
    97 00000057 66D1EB                           shr bx,1
    98 0000005A 6643                             inc bx
    99                                  
   100                                    .roll_screen:
   101 0000005C 6681FBD007                       cmp bx,2000                        ;光标超出屏幕？滚屏
   102 00000061 7C39                             jl .set_cursor
   103                                  
   104 00000063 1E                               push ds
   105 00000064 06                               push es
   106 00000065 B820000000                       mov eax,video_ram_seg_sel
   107 0000006A 8ED8                             mov ds,eax
   108 0000006C 8EC0                             mov es,eax
   109 0000006E FC                               cld
   110 0000006F BEA0000000                       mov esi,0xa0                       ;小心！32位模式下movsb/w/d 
   111 00000074 BF00000000                       mov edi,0x00                       ;使用的是esi/edi/ecx 
   112 00000079 B980070000                       mov ecx,1920
   113 0000007E F3A5                             rep movsd
   114 00000080 66BB000F                         mov bx,3840                        ;清除屏幕最底一行
   115 00000084 B950000000                       mov ecx,80                         ;32位程序应该使用ECX
   116                                    .cls:
   117 00000089 266667C7072007                   mov word[es:bx],0x0720
   118 00000090 6683C302                         add bx,2
   119 00000094 E2F3                             loop .cls
   120                                  
   121 00000096 07                               pop es
   122 00000097 1F                               pop ds
   123                                  
   124 00000098 66BB8007                         mov bx,1920
   125                                  
   126                                    .set_cursor:
   127 0000009C 66BAD403                         mov dx,0x3d4
   128 000000A0 B00E                             mov al,0x0e
   129 000000A2 EE                               out dx,al
   130 000000A3 6642                             inc dx                             ;0x3d5
   131 000000A5 88F8                             mov al,bh
   132 000000A7 EE                               out dx,al
   133 000000A8 664A                             dec dx                             ;0x3d4
   134 000000AA B00F                             mov al,0x0f
   135 000000AC EE                               out dx,al
   136 000000AD 6642                             inc dx                             ;0x3d5
   137 000000AF 88D8                             mov al,bl
   138 000000B1 EE                               out dx,al
   139                                  
   140 000000B2 61                               popad
   141                                           
   142 000000B3 C3                               ret                                
   143                                  
   144                                  ;-------------------------------------------------------------------------------
   145                                  read_hard_disk_0:                           ;从硬盘读取一个逻辑扇区
   146                                                                              ;EAX=逻辑扇区号
   147                                                                              ;DS:EBX=目标缓冲区地址
   148                                                                              ;返回：EBX=EBX+512
   149 000000B4 50                               push eax 
   150 000000B5 51                               push ecx
   151 000000B6 52                               push edx
   152                                        
   153 000000B7 50                               push eax
   154                                           
   155 000000B8 66BAF201                         mov dx,0x1f2
   156 000000BC B001                             mov al,1
   157 000000BE EE                               out dx,al                          ;读取的扇区数
   158                                  
   159 000000BF 6642                             inc dx                             ;0x1f3
   160 000000C1 58                               pop eax
   161 000000C2 EE                               out dx,al                          ;LBA地址7~0
   162                                  
   163 000000C3 6642                             inc dx                             ;0x1f4
   164 000000C5 B108                             mov cl,8
   165 000000C7 D3E8                             shr eax,cl
   166 000000C9 EE                               out dx,al                          ;LBA地址15~8
   167                                  
   168 000000CA 6642                             inc dx                             ;0x1f5
   169 000000CC D3E8                             shr eax,cl
   170 000000CE EE                               out dx,al                          ;LBA地址23~16
   171                                  
   172 000000CF 6642                             inc dx                             ;0x1f6
   173 000000D1 D3E8                             shr eax,cl
   174 000000D3 0CE0                             or al,0xe0                         ;第一硬盘  LBA地址27~24
   175 000000D5 EE                               out dx,al
   176                                  
   177 000000D6 6642                             inc dx                             ;0x1f7
   178 000000D8 B020                             mov al,0x20                        ;读命令
   179 000000DA EE                               out dx,al
   180                                  
   181                                    .waits:
   182 000000DB EC                               in al,dx
   183 000000DC 2488                             and al,0x88
   184 000000DE 3C08                             cmp al,0x08
   185 000000E0 75F9                             jnz .waits                         ;不忙，且硬盘已准备好数据传输 
   186                                  
   187 000000E2 B900010000                       mov ecx,256                        ;总共要读取的字数
   188 000000E7 66BAF001                         mov dx,0x1f0
   189                                    .readw:
   190 000000EB 66ED                             in ax,dx
   191 000000ED 668903                           mov [ebx],ax
   192 000000F0 83C302                           add ebx,2
   193 000000F3 E2F6                             loop .readw
   194                                  
   195 000000F5 5A                               pop edx
   196 000000F6 59                               pop ecx
   197 000000F7 58                               pop eax
   198                                        
   199 000000F8 CB                               retf                               ;段间返回 
   200                                  
   201                                  ;-------------------------------------------------------------------------------
   202                                  ;汇编语言程序是极难一次成功，而且调试非常困难。这个例程可以提供帮助 
   203                                  put_hex_dword:                              ;在当前光标处以十六进制形式显示
   204                                                                              ;一个双字并推进光标 
   205                                                                              ;输入：EDX=要转换并显示的数字
   206                                                                              ;输出：无
   207 000000F9 60                               pushad
   208 000000FA 1E                               push ds
   209                                        
   210 000000FB 66B83000                         mov ax,core_data_seg_sel           ;切换到核心数据段 
   211 000000FF 8ED8                             mov ds,ax
   212                                        
   213 00000101 BB[D5040000]                     mov ebx,bin_hex                    ;指向核心数据段内的转换表
   214 00000106 B908000000                       mov ecx,8
   215                                    .xlt:    
   216 0000010B C1C204                           rol edx,4
   217 0000010E 89D0                             mov eax,edx
   218 00000110 83E00F                           and eax,0x0000000f
   219 00000113 D7                               xlat
   220                                        
   221 00000114 51                               push ecx
   222 00000115 88C1                             mov cl,al                           
   223 00000117 E8F5FEFFFF                       call put_char
   224 0000011C 59                               pop ecx
   225                                         
   226 0000011D E2EC                             loop .xlt
   227                                        
   228 0000011F 1F                               pop ds
   229 00000120 61                               popad
   230 00000121 CB                               retf
   231                                        
   232                                  ;-------------------------------------------------------------------------------
   233                                  allocate_memory:                            ;分配内存
   234                                                                              ;输入：ECX=希望分配的字节数
   235                                                                              ;输出：ECX=起始线性地址 
   236 00000122 1E                               push ds
   237 00000123 50                               push eax
   238 00000124 53                               push ebx
   239                                        
   240 00000125 B830000000                       mov eax,core_data_seg_sel
   241 0000012A 8ED8                             mov ds,eax
   242                                        
   243 0000012C A1[06000000]                     mov eax,[ram_alloc]
   244 00000131 01C8                             add eax,ecx                        ;下一次分配时的起始地址
   245                                        
   246                                           ;这里应当有检测可用内存数量的指令
   247                                            
   248 00000133 8B0D[06000000]                   mov ecx,[ram_alloc]                ;返回分配的起始地址
   249                                  
   250 00000139 89C3                             mov ebx,eax
   251 0000013B 83E3FC                           and ebx,0xfffffffc
   252 0000013E 83C304                           add ebx,4                          ;强制对齐 
   253 00000141 A903000000                       test eax,0x00000003                ;下次分配的起始地址最好是4字节对齐
   254 00000146 0F45C3                           cmovnz eax,ebx                     ;如果没有对齐，则强制对齐 
   255 00000149 A3[06000000]                     mov [ram_alloc],eax                ;下次从该地址分配内存
   256                                                                              ;cmovcc指令可以避免控制转移 
   257 0000014E 5B                               pop ebx
   258 0000014F 58                               pop eax
   259 00000150 1F                               pop ds
   260                                  
   261 00000151 CB                               retf
   262                                  
   263                                  ;-------------------------------------------------------------------------------
   264                                  set_up_gdt_descriptor:                      ;在GDT内安装一个新的描述符
   265                                                                              ;输入：EDX:EAX=描述符 
   266                                                                              ;输出：CX=描述符的选择子
   267 00000152 50                               push eax
   268 00000153 53                               push ebx
   269 00000154 52                               push edx
   270                                  
   271 00000155 1E                               push ds
   272 00000156 06                               push es
   273                                  
   274 00000157 BB30000000                       mov ebx,core_data_seg_sel          ;切换到核心数据段
   275 0000015C 8EDB                             mov ds,ebx
   276                                  
   277 0000015E 0F0105[00000000]                 sgdt [pgdt]                        ;以便开始处理GDT
   278                                  
   279 00000165 BB08000000                       mov ebx,mem_0_4_gb_seg_sel
   280 0000016A 8EC3                             mov es,ebx
   281                                  
   282 0000016C 0FB71D[00000000]                 movzx ebx,word [pgdt]              ;GDT界限
   283 00000173 6643                             inc bx                             ;GDT总字节数，也是下一个描述符偏移
   284 00000175 031D[02000000]                   add ebx,[pgdt+2]                   ;下一个描述符的线性地址
   285                                  
   286 0000017B 268903                           mov [es:ebx],eax
   287 0000017E 26895304                         mov [es:ebx+4],edx
   288                                  
   289 00000182 668305[00000000]08               add word [pgdt],8                  ;增加一个描述符的大小
   290                                  
   291 0000018A 0F0115[00000000]                 lgdt [pgdt]                        ;对GDT的更改生效
   292                                  
   293 00000191 66A1[00000000]                   mov ax,[pgdt]                      ;得到GDT界限值
   294 00000197 6631D2                           xor dx,dx
   295 0000019A 66BB0800                         mov bx,8
   296 0000019E 66F7F3                           div bx                             ;除以8，去掉余数
   297 000001A1 6689C1                           mov cx,ax
   298 000001A4 66C1E103                         shl cx,3                           ;将索引号移到正确位置
   299                                  
   300 000001A8 07                               pop es
   301 000001A9 1F                               pop ds
   302                                  
   303 000001AA 5A                               pop edx
   304 000001AB 5B                               pop ebx
   305 000001AC 58                               pop eax
   306                                  
   307 000001AD CB                               retf
   308                                  ;-------------------------------------------------------------------------------
   309                                  make_seg_descriptor:                        ;构造存储器和系统的段描述符
   310                                                                              ;输入：EAX=线性基地址
   311                                                                              ;      EBX=段界限
   312                                                                              ;      ECX=属性。各属性位都在原始
   313                                                                              ;          位置，无关的位清零 
   314                                                                              ;返回：EDX:EAX=描述符
   315 000001AE 89C2                             mov edx,eax
   316 000001B0 C1E010                           shl eax,16
   317 000001B3 6609D8                           or ax,bx                           ;描述符前32位(EAX)构造完毕
   318                                  
   319 000001B6 81E20000FFFF                     and edx,0xffff0000                 ;清除基地址中无关的位
   320 000001BC C1C208                           rol edx,8
   321 000001BF 0FCA                             bswap edx                          ;装配基址的31~24和23~16  (80486+)
   322                                  
   323 000001C1 6631DB                           xor bx,bx
   324 000001C4 09DA                             or edx,ebx                         ;装配段界限的高4位
   325                                  
   326 000001C6 09CA                             or edx,ecx                         ;装配属性
   327                                  
   328 000001C8 CB                               retf
   329                                  
   330                                  ;-------------------------------------------------------------------------------
   331                                  make_gate_descriptor:                       ;构造门的描述符（调用门等）
   332                                                                              ;输入：EAX=门代码在段内偏移地址
   333                                                                              ;       BX=门代码所在段的选择子 
   334                                                                              ;       CX=段类型及属性等（各属
   335                                                                              ;          性位都在原始位置）
   336                                                                              ;返回：EDX:EAX=完整的描述符
   337 000001C9 53                               push ebx
   338 000001CA 51                               push ecx
   339                                        
   340 000001CB 89C2                             mov edx,eax
   341 000001CD 81E20000FFFF                     and edx,0xffff0000                 ;得到偏移地址高16位 
   342 000001D3 6609CA                           or dx,cx                           ;组装属性部分到EDX
   343                                         
   344 000001D6 25FFFF0000                       and eax,0x0000ffff                 ;得到偏移地址低16位 
   345 000001DB C1E310                           shl ebx,16                          
   346 000001DE 09D8                             or eax,ebx                         ;组装段选择子部分
   347                                        
   348 000001E0 59                               pop ecx
   349 000001E1 5B                               pop ebx
   350                                        
   351 000001E2 CB                               retf                                   
   352                                                               
   353                                  ;-------------------------------------------------------------------------------
   354                                  terminate_current_task:                     ;终止当前任务
   355                                                                              ;注意，执行此例程时，当前任务仍在
   356                                                                              ;运行中。此例程其实也是当前任务的
   357                                                                              ;一部分 
   358 000001E3 9C                               pushfd                             ;EFLAGS寄存器压栈
   359 000001E4 8B1424                           mov edx,[esp]                      ;从栈顶获得EFLAGS寄存器内容32位下独有做法
   360 000001E7 83C404                           add esp,4                          ;恢复堆栈指针
   361                                  
   362 000001EA B830000000                       mov eax,core_data_seg_sel
   363 000001EF 8ED8                             mov ds,eax
   364                                  
   365 000001F1 66F7C20040                       test dx,0100_0000_0000_0000B       ;测试NT位14位
   366 000001F6 7512                             jnz .b1                            ;当前任务是嵌套的，到.b1执行iretd 14位不是0
   367 000001F8 BB[EB0E0000]                     mov ebx,core_msg1                  ;当前任务不是嵌套的，直接切换到 
   368 000001FD 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   369 00000204 FF2D[270D0000]                   jmp far [prgman_tss]               ;程序管理器任务，任务管理器TSS基址 
   370                                         
   371                                    .b1: 
   372 0000020A BB[5E0E0000]                     mov ebx,core_msg0
   373 0000020F 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   374 00000216 CF                               iret
   375                                        
   376                                  sys_routine_end:
   377                                  
   378                                  ;===============================================================================
   379                                  SECTION core_data vstart=0                  ;系统核心的数据段 
   380                                  ;------------------------------------------------------------------------------- 
   381 00000000 0000                             pgdt             dw  0             ;用于设置和修改GDT 
   382 00000002 00000000                                          dd  0
   383                                  
   384 00000006 00001000                         ram_alloc        dd  0x00100000    ;下次分配内存时的起始地址
   385                                  
   386                                           ;符号地址检索表
   387                                           salt:
   388 0000000A 405072696E74537472-              salt_1           db  '@PrintString'
   388 00000013 696E67             
   389 00000016 00<rept>                                     times 256-($-salt_1) db 0
   390 0000010A [00000000]                                        dd  put_string
   391 0000010E 2800                                              dw  sys_routine_seg_sel
   392                                  
   393 00000110 40526561644469736B-              salt_2           db  '@ReadDiskData'
   393 00000119 44617461           
   394 0000011D 00<rept>                                     times 256-($-salt_2) db 0
   395 00000210 [B4000000]                                        dd  read_hard_disk_0
   396 00000214 2800                                              dw  sys_routine_seg_sel
   397                                  
   398 00000216 405072696E7444776F-              salt_3           db  '@PrintDwordAsHexString'
   398 0000021F 726441734865785374-
   398 00000228 72696E67           
   399 0000022C 00<rept>                                     times 256-($-salt_3) db 0
   400 00000316 [F9000000]                                        dd  put_hex_dword
   401 0000031A 2800                                              dw  sys_routine_seg_sel
   402                                  
   403 0000031C 405465726D696E6174-              salt_4           db  '@TerminateProgram'
   403 00000325 6550726F6772616D   
   404 0000032D 00<rept>                                     times 256-($-salt_4) db 0
   405 0000041C [E3010000]                                        dd  terminate_current_task
   406 00000420 2800                                              dw  sys_routine_seg_sel
   407                                  
   408                                           salt_item_len   equ $-salt_4
   409                                           salt_items      equ ($-salt)/salt_item_len
   410                                  
   411 00000422 2020496620796F7520-              message_1        db  '  If you seen this message,that means we '
   411 0000042B 7365656E2074686973-
   411 00000434 206D6573736167652C-
   411 0000043D 74686174206D65616E-
   411 00000446 7320776520         
   412 0000044B 617265206E6F772069-                               db  'are now in protect mode,and the system '
   412 00000454 6E2070726F74656374-
   412 0000045D 206D6F64652C616E64-
   412 00000466 207468652073797374-
   412 0000046F 656D20             
   413 00000472 636F7265206973206C-                               db  'core is loaded,and the video display '
   413 0000047B 6F616465642C616E64-
   413 00000484 207468652076696465-
   413 0000048D 6F20646973706C6179-
   413 00000496 20                 
   414 00000497 726F7574696E652077-                               db  'routine works perfectly.',0x0d,0x0a,0
   414 000004A0 6F726B732070657266-
   414 000004A9 6563746C792E0D0A00 
   415                                  
   416 000004B2 202053797374656D20-              message_2        db  '  System wide CALL-GATE mounted.',0x0d,0x0a,0
   416 000004BB 776964652043414C4C-
   416 000004C4 2D47415445206D6F75-
   416 000004CD 6E7465642E0D0A00   
   417                                           
   418 000004D5 303132333435363738-              bin_hex          db '0123456789ABCDEF'
   418 000004DE 39414243444546     
   419                                                                              ;put_hex_dword子过程用的查找表 
   420                                  
   421 000004E5 00<rept>                         core_buf   times 2048 db 0         ;内核用的缓冲区
   422                                  
   423 00000CE5 0D0A202000                       cpu_brnd0        db 0x0d,0x0a,'  ',0
   424 00000CEA 00<rept>                         cpu_brand  times 52 db 0
   425 00000D1E 0D0A0D0A00                       cpu_brnd1        db 0x0d,0x0a,0x0d,0x0a,0
   426                                  
   427                                           ;任务控制块链
   428 00000D23 00000000                         tcb_chain        dd  0
   429                                  
   430                                           ;程序管理器的任务信息 
   431 00000D27 00000000                         prgman_tss       dd  0             ;程序管理器的TSS基地址；JMP返回时不会用它
   432 00000D2B 0000                                              dw  0             ;程序管理器的TSS描述符选择子 
   433                                  
   434 00000D2D 0D0A                             prgman_msg1      db  0x0d,0x0a
   435 00000D2F 5B50524F4752414D20-                               db  '[PROGRAM MANAGER]: Hello! I am Program Manager,'
   435 00000D38 4D414E414745525D3A-
   435 00000D41 2048656C6C6F212049-
   435 00000D4A 20616D2050726F6772-
   435 00000D53 616D204D616E616765-
   435 00000D5C 722C               
   436 00000D5E 72756E206174204350-                               db  'run at CPL=0.Now,create user task and switch '
   436 00000D67 4C3D302E4E6F772C63-
   436 00000D70 726561746520757365-
   436 00000D79 72207461736B20616E-
   436 00000D82 642073776974636820 
   437 00000D8B 746F20697420627920-                               db  'to it by the CALL instruction...',0x0d,0x0a,0
   437 00000D94 7468652043414C4C20-
   437 00000D9D 696E73747275637469-
   437 00000DA6 6F6E2E2E2E0D0A00   
   438                                                   
   439 00000DAE 0D0A                             prgman_msg2      db  0x0d,0x0a
   440 00000DB0 5B50524F4752414D20-                               db  '[PROGRAM MANAGER]: I am glad to regain control.'
   440 00000DB9 4D414E414745525D3A-
   440 00000DC2 204920616D20676C61-
   440 00000DCB 6420746F2072656761-
   440 00000DD4 696E20636F6E74726F-
   440 00000DDD 6C2E               
   441 00000DDF 4E6F772C6372656174-                               db  'Now,create another user task and switch to '
   441 00000DE8 6520616E6F74686572-
   441 00000DF1 207573657220746173-
   441 00000DFA 6B20616E6420737769-
   441 00000E03 74636820746F20     
   442 00000E0A 697420627920746865-                               db  'it by the JMP instruction...',0x0d,0x0a,0
   442 00000E13 204A4D5020696E7374-
   442 00000E1C 72756374696F6E2E2E-
   442 00000E25 2E0D0A00           
   443                                                   
   444 00000E29 0D0A                             prgman_msg3      db  0x0d,0x0a
   445 00000E2B 5B50524F4752414D20-                               db  '[PROGRAM MANAGER]: I am gain control again,'
   445 00000E34 4D414E414745525D3A-
   445 00000E3D 204920616D20676169-
   445 00000E46 6E20636F6E74726F6C-
   445 00000E4F 20616761696E2C     
   446 00000E56 48414C542E2E2E00                                  db  'HALT...',0
   447                                  
   448 00000E5E 0D0A                             core_msg0        db  0x0d,0x0a
   449 00000E60 5B53595354454D2043-                               db  '[SYSTEM CORE]: Uh...This task initiated with '
   449 00000E69 4F52455D3A2055682E-
   449 00000E72 2E2E54686973207461-
   449 00000E7B 736B20696E69746961-
   449 00000E84 746564207769746820 
   450 00000E8D 43414C4C20696E7374-                               db  'CALL instruction or an exeception/ interrupt,'
   450 00000E96 72756374696F6E206F-
   450 00000E9F 7220616E2065786563-
   450 00000EA8 657074696F6E2F2069-
   450 00000EB1 6E746572727570742C 
   451 00000EBA 73686F756C64207573-                               db  'should use IRETD instruction to switch back...'
   451 00000EC3 652049524554442069-
   451 00000ECC 6E737472756374696F-
   451 00000ED5 6E20746F2073776974-
   451 00000EDE 6368206261636B2E2E-
   451 00000EE7 2E                 
   452 00000EE8 0D0A00                                            db  0x0d,0x0a,0
   453                                  
   454 00000EEB 0D0A                             core_msg1        db  0x0d,0x0a
   455 00000EED 5B53595354454D2043-                               db  '[SYSTEM CORE]: Uh...This task initiated with '
   455 00000EF6 4F52455D3A2055682E-
   455 00000EFF 2E2E54686973207461-
   455 00000F08 736B20696E69746961-
   455 00000F11 746564207769746820 
   456 00000F1A 4A4D5020696E737472-                               db  'JMP instruction,  should switch to Program '
   456 00000F23 756374696F6E2C2020-
   456 00000F2C 73686F756C64207377-
   456 00000F35 6974636820746F2050-
   456 00000F3E 726F6772616D20     
   457 00000F45 4D616E616765722064-                               db  'Manager directly by the JMP instruction...'
   457 00000F4E 69726563746C792062-
   457 00000F57 7920746865204A4D50-
   457 00000F60 20696E737472756374-
   457 00000F69 696F6E2E2E2E       
   458 00000F6F 0D0A00                                            db  0x0d,0x0a,0
   459                                  
   460                                  core_data_end:
   461                                                 
   462                                  ;===============================================================================
   463                                  SECTION core_code vstart=0
   464                                  ;-------------------------------------------------------------------------------
   465                                  fill_descriptor_in_ldt:                     ;在LDT内安装一个新的描述符
   466                                                                              ;输入：EDX:EAX=描述符
   467                                                                              ;          EBX=TCB基地址
   468                                                                              ;输出：CX=描述符的选择子
   469 00000000 50                               push eax
   470 00000001 52                               push edx
   471 00000002 57                               push edi
   472 00000003 1E                               push ds
   473                                  
   474 00000004 B908000000                       mov ecx,mem_0_4_gb_seg_sel
   475 00000009 8ED9                             mov ds,ecx
   476                                  
   477 0000000B 8B7B0C                           mov edi,[ebx+0x0c]                 ;获得LDT基地址
   478                                           
   479 0000000E 31C9                             xor ecx,ecx
   480 00000010 668B4B0A                         mov cx,[ebx+0x0a]                  ;获得LDT界限
   481 00000014 6641                             inc cx                             ;LDT的总字节数，即新描述符偏移地址
   482                                           
   483 00000016 89040F                           mov [edi+ecx+0x00],eax
   484 00000019 89540F04                         mov [edi+ecx+0x04],edx             ;安装描述符
   485                                  
   486 0000001D 6683C108                         add cx,8                           
   487 00000021 6649                             dec cx                             ;得到新的LDT界限值 
   488                                  
   489 00000023 66894B0A                         mov [ebx+0x0a],cx                  ;更新LDT界限值到TCB
   490                                  
   491 00000027 6689C8                           mov ax,cx
   492 0000002A 6631D2                           xor dx,dx
   493 0000002D 66B90800                         mov cx,8
   494 00000031 66F7F1                           div cx
   495                                           
   496 00000034 6689C1                           mov cx,ax
   497 00000037 66C1E103                         shl cx,3                           ;左移3位，并且
   498 0000003B 6683C904                         or cx,0000_0000_0000_0100B         ;使TI位=1，指向LDT，最后使RPL=00 
   499                                  
   500 0000003F 1F                               pop ds
   501 00000040 5F                               pop edi
   502 00000041 5A                               pop edx
   503 00000042 58                               pop eax
   504                                       
   505 00000043 C3                               ret
   506                                           
   507                                  ;------------------------------------------------------------------------------- 
   508                                  load_relocate_program:                      ;加载并重定位用户程序
   509                                                                              ;输入: PUSH 逻辑扇区号
   510                                                                              ;      PUSH 任务控制块基地址
   511                                                                              ;输出：无 
   512 00000044 60                               pushad
   513                                        
   514 00000045 1E                               push ds
   515 00000046 06                               push es
   516                                        
   517 00000047 89E5                             mov ebp,esp                        ;为访问通过堆栈传递的参数做准备
   518                                        
   519 00000049 B908000000                       mov ecx,mem_0_4_gb_seg_sel
   520 0000004E 8EC1                             mov es,ecx
   521                                        
   522 00000050 8B752C                           mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
   523                                  
   524                                           ;以下申请创建LDT所需要的内存
   525 00000053 B9A0000000                       mov ecx,160                        ;允许安装20个LDT描述符
   526 00000058 9A[22010000]2800                 call sys_routine_seg_sel:allocate_memory
   527 0000005F 26894E0C                         mov [es:esi+0x0c],ecx              ;登记LDT基地址到TCB中
   528 00000063 2666C7460AFFFF                   mov word [es:esi+0x0a],0xffff      ;登记LDT初始的界限到TCB中 
   529                                  
   530                                           ;以下开始加载用户程序 
   531 0000006A B830000000                       mov eax,core_data_seg_sel
   532 0000006F 8ED8                             mov ds,eax                         ;切换DS到内核数据段
   533                                         
   534 00000071 8B4530                           mov eax,[ebp+12*4]                 ;从堆栈中取出用户程序起始扇区号 
   535 00000074 BB[E5040000]                     mov ebx,core_buf                   ;读取程序头部数据     
   536 00000079 9A[B4000000]2800                 call sys_routine_seg_sel:read_hard_disk_0
   537                                  
   538                                           ;以下判断整个程序有多大
   539 00000080 A1[E5040000]                     mov eax,[core_buf]                 ;程序尺寸
   540 00000085 89C3                             mov ebx,eax
   541 00000087 81E300FEFFFF                     and ebx,0xfffffe00                 ;使之512字节对齐（能被512整除的数低 
   542 0000008D 81C300020000                     add ebx,512                        ;9位都为0 
   543 00000093 A9FF010000                       test eax,0x000001ff                ;程序的大小正好是512的倍数吗? 
   544 00000098 0F45C3                           cmovnz eax,ebx                     ;不是。使用凑整的结果
   545                                        
   546 0000009B 89C1                             mov ecx,eax                        ;实际需要申请的内存数量
   547 0000009D 9A[22010000]2800                 call sys_routine_seg_sel:allocate_memory
   548 000000A4 26894E06                         mov [es:esi+0x06],ecx              ;登记程序加载基地址到TCB中
   549                                        
   550 000000A8 89CB                             mov ebx,ecx                        ;ebx -> 申请到的内存首地址
   551 000000AA 31D2                             xor edx,edx
   552 000000AC B900020000                       mov ecx,512
   553 000000B1 F7F1                             div ecx
   554 000000B3 89C1                             mov ecx,eax                        ;总扇区数 
   555                                        
   556 000000B5 B808000000                       mov eax,mem_0_4_gb_seg_sel         ;切换DS到0-4GB的段
   557 000000BA 8ED8                             mov ds,eax
   558                                  
   559 000000BC 8B4530                           mov eax,[ebp+12*4]                 ;起始扇区号 
   560                                    .b1:
   561 000000BF 9A[B4000000]2800                 call sys_routine_seg_sel:read_hard_disk_0
   562 000000C6 40                               inc eax
   563 000000C7 E2F6                             loop .b1                           ;循环读，直到读完整个用户程序
   564                                  
   565 000000C9 268B7E06                         mov edi,[es:esi+0x06]              ;获得程序加载基地址
   566                                  
   567                                           ;建立程序头部段描述符
   568 000000CD 89F8                             mov eax,edi                        ;程序头部起始线性地址
   569 000000CF 8B5F04                           mov ebx,[edi+0x04]                 ;段长度
   570 000000D2 4B                               dec ebx                            ;段界限
   571 000000D3 B900F24000                       mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3 
   572 000000D8 9A[AE010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   573                                        
   574                                           ;安装头部段描述符到LDT中 
   575 000000DF 89F3                             mov ebx,esi                        ;TCB的基地址
   576 000000E1 E81AFFFFFF                       call fill_descriptor_in_ldt
   577                                  
   578 000000E6 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   579 000000EA 2666894E44                       mov [es:esi+0x44],cx               ;登记程序头部段选择子到TCB 
   580 000000EF 66894F04                         mov [edi+0x04],cx                  ;和头部内 
   581                                        
   582                                           ;建立程序代码段描述符
   583 000000F3 89F8                             mov eax,edi
   584 000000F5 034714                           add eax,[edi+0x14]                 ;代码起始线性地址
   585 000000F8 8B5F18                           mov ebx,[edi+0x18]                 ;段长度
   586 000000FB 4B                               dec ebx                            ;段界限
   587 000000FC B900F84000                       mov ecx,0x0040f800                 ;字节粒度的代码段描述符，特权级3
   588 00000101 9A[AE010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   589 00000108 89F3                             mov ebx,esi                        ;TCB的基地址
   590 0000010A E8F1FEFFFF                       call fill_descriptor_in_ldt
   591 0000010F 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   592 00000113 66894F14                         mov [edi+0x14],cx                  ;登记代码段选择子到头部
   593                                  
   594                                           ;建立程序数据段描述符
   595 00000117 89F8                             mov eax,edi
   596 00000119 03471C                           add eax,[edi+0x1c]                 ;数据段起始线性地址
   597 0000011C 8B5F20                           mov ebx,[edi+0x20]                 ;段长度
   598 0000011F 4B                               dec ebx                            ;段界限 
   599 00000120 B900F24000                       mov ecx,0x0040f200                 ;字节粒度的数据段描述符，特权级3
   600 00000125 9A[AE010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   601 0000012C 89F3                             mov ebx,esi                        ;TCB的基地址
   602 0000012E E8CDFEFFFF                       call fill_descriptor_in_ldt
   603 00000133 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   604 00000137 66894F1C                         mov [edi+0x1c],cx                  ;登记数据段选择子到头部
   605                                  
   606                                           ;建立程序堆栈段描述符
   607 0000013B 8B4F0C                           mov ecx,[edi+0x0c]                 ;4KB的倍率 
   608 0000013E BBFFFF0F00                       mov ebx,0x000fffff
   609 00000143 29CB                             sub ebx,ecx                        ;得到段界限
   610 00000145 B800100000                       mov eax,4096                        
   611 0000014A F7E1                             mul ecx                         
   612 0000014C 89C1                             mov ecx,eax                        ;准备为堆栈分配内存 
   613 0000014E 9A[22010000]2800                 call sys_routine_seg_sel:allocate_memory
   614 00000155 01C8                             add eax,ecx                        ;得到堆栈的高端物理地址 
   615 00000157 B900F6C000                       mov ecx,0x00c0f600                 ;字节粒度的堆栈段描述符，特权级3
   616 0000015C 9A[AE010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   617 00000163 89F3                             mov ebx,esi                        ;TCB的基地址
   618 00000165 E896FEFFFF                       call fill_descriptor_in_ldt
   619 0000016A 6683C903                         or cx,0000_0000_0000_0011B         ;设置选择子的特权级为3
   620 0000016E 66894F08                         mov [edi+0x08],cx                  ;登记堆栈段选择子到头部
   621                                  
   622                                           ;重定位SALT 
   623 00000172 B808000000                       mov eax,mem_0_4_gb_seg_sel         ;这里和前一章不同，头部段描述符
   624 00000177 8EC0                             mov es,eax                         ;已安装，但还没有生效，故只能通
   625                                                                              ;过4GB段访问用户程序头部          
   626 00000179 B830000000                       mov eax,core_data_seg_sel
   627 0000017E 8ED8                             mov ds,eax
   628                                        
   629 00000180 FC                               cld
   630                                  
   631 00000181 268B4F24                         mov ecx,[es:edi+0x24]              ;U-SALT条目数(通过访问4GB段取得) 
   632 00000185 83C728                           add edi,0x28                       ;U-SALT在4GB段内的偏移 
   633                                    .b2: 
   634 00000188 51                               push ecx
   635 00000189 57                               push edi
   636                                        
   637 0000018A B904000000                       mov ecx,salt_items
   638 0000018F BE[0A000000]                     mov esi,salt
   639                                    .b3:
   640 00000194 57                               push edi
   641 00000195 56                               push esi
   642 00000196 51                               push ecx
   643                                  
   644 00000197 B940000000                       mov ecx,64                         ;检索表中，每条目的比较次数 
   645 0000019C F3A7                             repe cmpsd                         ;每次比较4字节 
   646 0000019E 7519                             jnz .b4
   647 000001A0 8B06                             mov eax,[esi]                      ;若匹配，则esi恰好指向其后的地址
   648 000001A2 26898700FFFFFF                   mov [es:edi-256],eax               ;将字符串改写成偏移地址 
   649 000001A9 668B4604                         mov ax,[esi+4]
   650 000001AD 6683C803                         or ax,0000000000000011B            ;以用户程序自己的特权级使用调用门
   651                                                                              ;故RPL=3 
   652 000001B1 2666898704FFFFFF                 mov [es:edi-252],ax                ;回填调用门选择子 
   653                                    .b4:
   654                                        
   655 000001B9 59                               pop ecx
   656 000001BA 5E                               pop esi
   657 000001BB 81C606010000                     add esi,salt_item_len
   658 000001C1 5F                               pop edi                            ;从头比较 
   659 000001C2 E2D0                             loop .b3
   660                                        
   661 000001C4 5F                               pop edi
   662 000001C5 81C700010000                     add edi,256
   663 000001CB 59                               pop ecx
   664 000001CC E2BA                             loop .b2
   665                                  
   666 000001CE 8B752C                           mov esi,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
   667                                  
   668                                           ;创建0特权级堆栈
   669 000001D1 B900100000                       mov ecx,4096
   670 000001D6 89C8                             mov eax,ecx                        ;为生成堆栈高端地址做准备 
   671 000001D8 26894E1A                         mov [es:esi+0x1a],ecx
   672 000001DC 26C16E1A0C                       shr dword [es:esi+0x1a],12         ;登记0特权级堆栈尺寸到TCB 
   673 000001E1 9A[22010000]2800                 call sys_routine_seg_sel:allocate_memory
   674 000001E8 01C8                             add eax,ecx                        ;堆栈必须使用高端地址为基地址
   675 000001EA 2689461E                         mov [es:esi+0x1e],eax              ;登记0特权级堆栈基地址到TCB 
   676 000001EE BBFEFF0F00                       mov ebx,0xffffe                    ;段长度（界限）
   677 000001F3 B90096C000                       mov ecx,0x00c09600                 ;4KB粒度，读写，特权级0
   678 000001F8 9A[AE010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   679 000001FF 89F3                             mov ebx,esi                        ;TCB的基地址
   680 00000201 E8FAFDFFFF                       call fill_descriptor_in_ldt
   681                                           ;or cx,0000_0000_0000_0000          ;设置选择子的特权级为0
   682 00000206 2666894E22                       mov [es:esi+0x22],cx               ;登记0特权级堆栈选择子到TCB
   683 0000020B 26C7462400000000                 mov dword [es:esi+0x24],0          ;登记0特权级堆栈初始ESP到TCB
   684                                        
   685                                           ;创建1特权级堆栈
   686 00000213 B900100000                       mov ecx,4096
   687 00000218 89C8                             mov eax,ecx                        ;为生成堆栈高端地址做准备
   688 0000021A 26894E28                         mov [es:esi+0x28],ecx
   689 0000021E 2666C16E280C                     shr word [es:esi+0x28],12               ;登记1特权级堆栈尺寸到TCB
   690 00000224 9A[22010000]2800                 call sys_routine_seg_sel:allocate_memory
   691 0000022B 01C8                             add eax,ecx                        ;堆栈必须使用高端地址为基地址
   692 0000022D 2689462C                         mov [es:esi+0x2c],eax              ;登记1特权级堆栈基地址到TCB
   693 00000231 BBFEFF0F00                       mov ebx,0xffffe                    ;段长度（界限）
   694 00000236 B900B6C000                       mov ecx,0x00c0b600                 ;4KB粒度，读写，特权级1
   695 0000023B 9A[AE010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   696 00000242 89F3                             mov ebx,esi                        ;TCB的基地址
   697 00000244 E8B7FDFFFF                       call fill_descriptor_in_ldt
   698 00000249 6683C901                         or cx,0000_0000_0000_0001          ;设置选择子的特权级为1
   699 0000024D 2666894E30                       mov [es:esi+0x30],cx               ;登记1特权级堆栈选择子到TCB
   700 00000252 26C7463200000000                 mov dword [es:esi+0x32],0          ;登记1特权级堆栈初始ESP到TCB
   701                                  
   702                                           ;创建2特权级堆栈
   703 0000025A B900100000                       mov ecx,4096
   704 0000025F 89C8                             mov eax,ecx                        ;为生成堆栈高端地址做准备
   705 00000261 26894E36                         mov [es:esi+0x36],ecx
   706 00000265 2666C16E360C                     shr Word [es:esi+0x36],12               ;登记2特权级堆栈尺寸到TCB
   707 0000026B 9A[22010000]2800                 call sys_routine_seg_sel:allocate_memory
   708 00000272 01C8                             add eax,ecx                        ;堆栈必须使用高端地址为基地址
   709 00000274 26894E3A                         mov [es:esi+0x3a],ecx              ;登记2特权级堆栈基地址到TCB
   710 00000278 BBFEFF0F00                       mov ebx,0xffffe                    ;段长度（界限）
   711 0000027D B900D6C000                       mov ecx,0x00c0d600                 ;4KB粒度，读写，特权级2
   712 00000282 9A[AE010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   713 00000289 89F3                             mov ebx,esi                        ;TCB的基地址
   714 0000028B E870FDFFFF                       call fill_descriptor_in_ldt
   715 00000290 6683C90A                         or cx,0000_0000_0000_0010          ;设置选择子的特权级为2
   716 00000294 2666894E3E                       mov [es:esi+0x3e],cx               ;登记2特权级堆栈选择子到TCB
   717 00000299 26C7464000000000                 mov dword [es:esi+0x40],0          ;登记2特权级堆栈初始ESP到TCB
   718                                        
   719                                           ;在GDT中登记LDT描述符
   720 000002A1 268B460C                         mov eax,[es:esi+0x0c]              ;LDT的起始线性地址
   721 000002A5 260FB75E0A                       movzx ebx,word [es:esi+0x0a]       ;LDT段界限
   722 000002AA B900824000                       mov ecx,0x00408200                 ;LDT描述符，特权级0
   723 000002AF 9A[AE010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   724 000002B6 9A[52010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   725 000002BD 2666894E10                       mov [es:esi+0x10],cx               ;登记LDT选择子到TCB中
   726                                         
   727                                           ;创建用户程序的TSS
   728 000002C2 B968000000                       mov ecx,104                        ;tss的基本尺寸
   729 000002C7 2666894E12                       mov [es:esi+0x12],cx              
   730 000002CC 2666FF4E12                       dec word [es:esi+0x12]             ;登记TSS界限值到TCB 
   731 000002D1 9A[22010000]2800                 call sys_routine_seg_sel:allocate_memory
   732 000002D8 26894E14                         mov [es:esi+0x14],ecx              ;登记TSS基地址到TCB
   733                                        
   734                                           ;登记基本的TSS表格内容
   735 000002DC 2666C7010000                     mov word [es:ecx+0],0              ;反向链=0
   736                                        
   737 000002E2 268B5624                         mov edx,[es:esi+0x24]              ;登记0特权级堆栈初始ESP
   738 000002E6 26895104                         mov [es:ecx+4],edx                 ;到TSS中
   739                                        
   740 000002EA 26668B5622                       mov dx,[es:esi+0x22]               ;登记0特权级堆栈段选择子
   741 000002EF 2666895108                       mov [es:ecx+8],dx                  ;到TSS中
   742                                        
   743 000002F4 268B5632                         mov edx,[es:esi+0x32]              ;登记1特权级堆栈初始ESP
   744 000002F8 2689510C                         mov [es:ecx+12],edx                ;到TSS中
   745                                  
   746 000002FC 26668B5630                       mov dx,[es:esi+0x30]               ;登记1特权级堆栈段选择子
   747 00000301 2666895110                       mov [es:ecx+16],dx                 ;到TSS中
   748                                  
   749 00000306 268B5640                         mov edx,[es:esi+0x40]              ;登记2特权级堆栈初始ESP
   750 0000030A 26895114                         mov [es:ecx+20],edx                ;到TSS中
   751                                  
   752 0000030E 26668B563E                       mov dx,[es:esi+0x3e]               ;登记2特权级堆栈段选择子
   753 00000313 2666895118                       mov [es:ecx+24],dx                 ;到TSS中
   754                                  
   755 00000318 26668B5610                       mov dx,[es:esi+0x10]               ;登记任务的LDT选择子
   756 0000031D 2666895160                       mov [es:ecx+96],dx                 ;到TSS中
   757                                        
   758 00000322 26668B5612                       mov dx,[es:esi+0x12]               ;登记任务的I/O位图偏移
   759 00000327 2666895166                       mov [es:ecx+102],dx                ;到TSS中 
   760                                        
   761 0000032C 2666C741640000                   mov word [es:ecx+100],0            ;T=0
   762                                        
   763 00000333 26C7411C00000000                 mov dword [es:ecx+28],0            ;登记CR3(PDBR)
   764                                        
   765                                           ;访问用户程序头部，获取数据填充TSS 
   766 0000033B 8B5D2C                           mov ebx,[ebp+11*4]                 ;从堆栈中取得TCB的基地址
   767 0000033E 268B7B06                         mov edi,[es:ebx+0x06]              ;用户程序加载的基地址 
   768                                  
   769 00000342 268B5710                         mov edx,[es:edi+0x10]              ;登记程序入口点（EIP） 
   770 00000346 26895120                         mov [es:ecx+32],edx                ;到TSS
   771                                  
   772 0000034A 26668B5714                       mov dx,[es:edi+0x14]               ;登记程序代码段（CS）选择子
   773 0000034F 266689514C                       mov [es:ecx+76],dx                 ;到TSS中
   774                                  
   775 00000354 26668B5708                       mov dx,[es:edi+0x08]               ;登记程序堆栈段（SS）选择子
   776 00000359 2666895150                       mov [es:ecx+80],dx                 ;到TSS中
   777                                  
   778 0000035E 26668B5704                       mov dx,[es:edi+0x04]               ;登记程序数据段（DS）选择子
   779 00000363 2666895154                       mov word [es:ecx+84],dx            ;到TSS中。注意，它指向程序头部段
   780                                        
   781 00000368 2666C741480000                   mov word [es:ecx+72],0             ;TSS中的ES=0
   782                                  
   783 0000036F 2666C741580000                   mov word [es:ecx+88],0             ;TSS中的FS=0
   784                                  
   785 00000376 2666C7415C0000                   mov word [es:ecx+92],0             ;TSS中的GS=0
   786                                  
   787 0000037D 9C                               pushfd
   788 0000037E 5A                               pop edx
   789                                           
   790 0000037F 26895124                         mov dword [es:ecx+36],edx          ;EFLAGS
   791                                  
   792                                           ;在GDT中登记TSS描述符
   793 00000383 268B4614                         mov eax,[es:esi+0x14]              ;TSS的起始线性地址
   794 00000387 260FB75E12                       movzx ebx,word [es:esi+0x12]       ;段长度（界限）
   795 0000038C B900894000                       mov ecx,0x00408900                 ;TSS描述符，特权级0
   796 00000391 9A[AE010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   797 00000398 9A[52010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   798 0000039F 2666894E18                       mov [es:esi+0x18],cx               ;登记TSS选择子到TCB
   799                                  
   800 000003A4 07                               pop es                             ;恢复到调用此过程前的es段 
   801 000003A5 1F                               pop ds                             ;恢复到调用此过程前的ds段
   802                                        
   803 000003A6 61                               popad
   804                                        
   805 000003A7 C20800                           ret 8                              ;丢弃调用本过程前压入的参数 
   806                                        
   807                                  ;-------------------------------------------------------------------------------
   808                                  append_to_tcb_link:                         ;在TCB链上追加任务控制块
   809                                                                              ;输入：ECX=TCB线性基地址
   810 000003AA 50                               push eax
   811 000003AB 52                               push edx
   812 000003AC 1E                               push ds
   813 000003AD 06                               push es
   814                                           
   815 000003AE B830000000                       mov eax,core_data_seg_sel          ;令DS指向内核数据段 
   816 000003B3 8ED8                             mov ds,eax
   817 000003B5 B808000000                       mov eax,mem_0_4_gb_seg_sel         ;令ES指向0..4GB段
   818 000003BA 8EC0                             mov es,eax
   819                                           
   820 000003BC 26C70100000000                   mov dword [es: ecx+0x00],0         ;当前TCB指针域清零，以指示这是最
   821                                                                              ;后一个TCB
   822                                                                               
   823 000003C3 A1[230D0000]                     mov eax,[tcb_chain]                ;TCB表头指针
   824 000003C8 09C0                             or eax,eax                         ;链表为空？
   825 000003CA 740E                             jz .notcb 
   826                                           
   827                                    .searc:
   828 000003CC 89C2                             mov edx,eax
   829 000003CE 268B02                           mov eax,[es: edx+0x00]
   830 000003D1 09C0                             or eax,eax               
   831 000003D3 75F7                             jnz .searc
   832                                           
   833 000003D5 26890A                           mov [es: edx+0x00],ecx
   834 000003D8 EB06                             jmp .retpc
   835                                           
   836                                    .notcb:       
   837 000003DA 890D[230D0000]                   mov [tcb_chain],ecx                ;若为空表，直接令表头指针指向TCB
   838                                           
   839                                    .retpc:
   840 000003E0 07                               pop es
   841 000003E1 1F                               pop ds
   842 000003E2 5A                               pop edx
   843 000003E3 58                               pop eax
   844                                           
   845 000003E4 C3                               ret
   846                                           
   847                                  ;-------------------------------------------------------------------------------
   848                                  start:
   849 000003E5 B930000000                       mov ecx,core_data_seg_sel          ;令DS指向核心数据段 
   850 000003EA 8ED9                             mov ds,ecx
   851                                  
   852 000003EC B908000000                       mov ecx,mem_0_4_gb_seg_sel         ;令ES指向4GB数据段 
   853 000003F1 8EC1                             mov es,ecx
   854                                  
   855 000003F3 BB[22040000]                     mov ebx,message_1                    
   856 000003F8 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   857                                                                           
   858                                           ;显示处理器品牌信息 
   859 000003FF B802000080                       mov eax,0x80000002
   860 00000404 0FA2                             cpuid
   861 00000406 A3[EA0C0000]                     mov [cpu_brand + 0x00],eax
   862 0000040B 891D[EE0C0000]                   mov [cpu_brand + 0x04],ebx
   863 00000411 890D[F20C0000]                   mov [cpu_brand + 0x08],ecx
   864 00000417 8915[F60C0000]                   mov [cpu_brand + 0x0c],edx
   865                                        
   866 0000041D B803000080                       mov eax,0x80000003
   867 00000422 0FA2                             cpuid
   868 00000424 A3[FA0C0000]                     mov [cpu_brand + 0x10],eax
   869 00000429 891D[FE0C0000]                   mov [cpu_brand + 0x14],ebx
   870 0000042F 890D[020D0000]                   mov [cpu_brand + 0x18],ecx
   871 00000435 8915[060D0000]                   mov [cpu_brand + 0x1c],edx
   872                                  
   873 0000043B B804000080                       mov eax,0x80000004
   874 00000440 0FA2                             cpuid
   875 00000442 A3[0A0D0000]                     mov [cpu_brand + 0x20],eax
   876 00000447 891D[0E0D0000]                   mov [cpu_brand + 0x24],ebx
   877 0000044D 890D[120D0000]                   mov [cpu_brand + 0x28],ecx
   878 00000453 8915[160D0000]                   mov [cpu_brand + 0x2c],edx
   879                                  
   880 00000459 BB[E50C0000]                     mov ebx,cpu_brnd0                  ;显示处理器品牌信息 
   881 0000045E 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   882 00000465 BB[EA0C0000]                     mov ebx,cpu_brand
   883 0000046A 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   884 00000471 BB[1E0D0000]                     mov ebx,cpu_brnd1
   885 00000476 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   886                                  
   887                                           ;以下开始安装为整个系统服务的调用门。特权级之间的控制转移必须使用门
   888 0000047D BF[0A000000]                     mov edi,salt                       ;C-SALT表的起始位置 
   889 00000482 B904000000                       mov ecx,salt_items                 ;C-SALT表的条目数量 
   890                                    .b3:
   891 00000487 51                               push ecx   
   892 00000488 8B8700010000                     mov eax,[edi+256]                  ;该条目入口点的32位偏移地址 
   893 0000048E 668B9F04010000                   mov bx,[edi+260]                   ;该条目入口点的段选择子 
   894 00000495 66B900EC                         mov cx,1_11_0_1100_000_00000B      ;特权级3的调用门(3以上的特权级才
   895                                                                              ;允许访问)，0个参数(因为用寄存器
   896                                                                              ;传递参数，而没有用栈) 
   897 00000499 9A[C9010000]2800                 call sys_routine_seg_sel:make_gate_descriptor
   898 000004A0 9A[52010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   899 000004A7 66898F04010000                   mov [edi+260],cx                   ;将返回的门描述符选择子回填
   900 000004AE 81C706010000                     add edi,salt_item_len              ;指向下一个C-SALT条目 
   901 000004B4 59                               pop ecx
   902 000004B5 E2D0                             loop .b3
   903                                  
   904                                           ;对门进行测试 
   905 000004B7 BB[B2040000]                     mov ebx,message_2
   906 000004BC FF1D[0A010000]                   call far [salt_1+256]              ;通过门显示信息(偏移量将被忽略) 
   907                                        
   908                                           ;为程序管理器的TSS分配内存空间 
   909 000004C2 B968000000                       mov ecx,104                        ;为该任务的TSS分配内存
   910 000004C7 9A[22010000]2800                 call sys_routine_seg_sel:allocate_memory
   911 000004CE 890D[270D0000]                   mov [prgman_tss+0x00],ecx          ;保存程序管理器的TSS基地址 
   912                                        
   913                                           ;在程序管理器的TSS中设置必要的项目 
   914 000004D4 2666C741600000                   mov word [es:ecx+96],0             ;没有LDT。处理器允许没有LDT的任务。
   915 000004DB 2666C741666700                   mov word [es:ecx+102],103          ;没有I/O位图。0特权级事实上不需要。
   916 000004E2 2666C7010000                     mov word [es:ecx+0],0              ;反向链=0
   917 000004E8 26C7411C00000000                 mov dword [es:ecx+28],0            ;登记CR3(PDBR)
   918 000004F0 2666C741640000                   mov word [es:ecx+100],0            ;T=0
   919                                                                              ;不需要0、1、2特权级堆栈。0特级不
   920                                                                              ;会向低特权级转移控制。
   921                                           
   922                                           ;创建TSS描述符，并安装到GDT中 
   923 000004F7 89C8                             mov eax,ecx                        ;TSS的起始线性地址
   924 000004F9 BB67000000                       mov ebx,103                        ;段长度（界限）
   925 000004FE B900894000                       mov ecx,0x00408900                 ;TSS描述符，特权级0
   926 00000503 9A[AE010000]2800                 call sys_routine_seg_sel:make_seg_descriptor
   927 0000050A 9A[52010000]2800                 call sys_routine_seg_sel:set_up_gdt_descriptor
   928 00000511 66890D[2B0D0000]                 mov [prgman_tss+0x04],cx           ;保存程序管理器的TSS描述符选择子 
   929                                  
   930                                           ;任务寄存器TR中的内容是任务存在的标志，该内容也决定了当前任务是谁。
   931                                           ;下面的指令为当前正在执行的0特权级任务“程序管理器”后补手续（TSS）。
   932 00000518 0F00D9                           ltr cx ;load TSS to task register                            
   933                                  
   934                                           ;现在可认为“程序管理器”任务正执行中
   935 0000051B BB[2D0D0000]                     mov ebx,prgman_msg1
   936 00000520 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   937                                  
   938                                  		 ;以下加载用户程序
   939 00000527 B946000000                       mov ecx,0x46                       ;分配任务控制块
   940 0000052C 9A[22010000]2800                 call sys_routine_seg_sel:allocate_memory
   941 00000533 E872FEFFFF                       call append_to_tcb_link            ;将此TCB添加到TCB链中 
   942                                        
   943 00000538 6A32                             push dword 50                      ;用户程序位于逻辑50扇区
   944 0000053A 51                               push ecx                           ;压入任务控制块起始线性地址 
   945                                         
   946 0000053B E804FBFFFF                       call load_relocate_program         ;加载用户程序  
   947                                           ;ES指向0-4GB ecx为用户程序任务控制块基址，0x14偏向TSS选择子，32位偏移忽略掉
   948 00000540 26FF5914                         call far [es:ecx+0x14]             ;执行任务切换。和上一章不同，任务切
   949                                                                              ;换时要恢复TSS内容，所以在创建任务
   950                                                                              ;时TSS要填写完整 
   951                                           ;////////////////////////////////////////////////////////////////////////////////                                
   952                                           ;重新加载并切换任务
   953                                           ;上一个用户程序并没有消失，因为没有回收内存		 
   954 00000544 BB[AE0D0000]                     mov ebx,prgman_msg2
   955 00000549 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   956                                           ;再次发起用户程序
   957 00000550 B946000000                       mov ecx,0x46
   958 00000555 9A[22010000]2800                 call sys_routine_seg_sel:allocate_memory
   959 0000055C E849FEFFFF                       call append_to_tcb_link            ;将此TCB添加到TCB链中
   960                                  
   961 00000561 6A64                             push dword 100                      ;用户程序位于逻辑50扇区
   962 00000563 51                               push ecx                           ;压入任务控制块起始线性地址
   963                                  
   964 00000564 E8DBFAFFFF                       call load_relocate_program
   965                                  
   966 00000569 26FF6914                         jmp far [es:ecx+0x14]              ;执行任务切换；这次用的是jmp指令，不会发生嵌套
   967                                  
   968                                  		 ;返回点
   969 0000056D BB[290E0000]                     mov ebx,prgman_msg3
   970 00000572 9A[00000000]2800                 call sys_routine_seg_sel:put_string
   971                                  
   972 00000579 F4                               hlt
   973                                              
   974                                  core_code_end:
   975                                  
   976                                  ;-------------------------------------------------------------------------------
   977                                  SECTION core_trail
   978                                  ;-------------------------------------------------------------------------------
   979                                  core_end:
