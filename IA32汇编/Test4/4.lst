     1                                  ;===============================================================================
     2                                  SECTION header vstart=0                     ;定义用户程序头部段 
     3 00000000 [00000000]                  program_length  dd program_end          ;程序总长度[0x00];dd32bit
     4                                      
     5                                      ;用户程序入口点
     6 00000004 [FB00]                      code_entry      dw start                ;偏移地址[0x04]
     7 00000006 [00000000]                                  dd section.code.start   ;段地址[0x06] 
     8                                      
     9 0000000A 0300                        realloc_tbl_len dw (header_end-realloc_begin)/4
    10                                                                              ;段重定位表项个数[0x0a]
    11                                      
    12                                      realloc_begin:
    13                                      ;段重定位表           
    14 0000000C [00000000]                  code_segment    dd section.code.start   ;[0x0c]
    15 00000010 [00000000]                  data_segment    dd section.data.start   ;[0x14]
    16 00000014 [00000000]                  stack_segment   dd section.stack.start  ;[0x1c]
    17                                      
    18                                  header_end:                
    19                                      
    20                                  ;===============================================================================
    21                                  SECTION code align=16 vstart=0           ;定义代码段（16字节对齐
    22                                  new_int_0x70:
    23 00000000 50                            push ax
    24 00000001 53                            push bx
    25 00000002 51                            push cx
    26 00000003 52                            push dx
    27 00000004 06                            push es
    28                                        
    29 00000005 31C0                          xor ax,ax 
    30                                        ;读取星期 
    31 00000007 B006                          mov al,0x06
    32 00000009 E670                          out 0x70,al
    33 0000000B E471                          in al,0x71
    34 0000000D 50                            push ax
    35                                        
    36                                        ;读取秒
    37 0000000E B000                          mov al,0x00
    38 00000010 E670                          out 0x70,al
    39 00000012 E471                          in al,0x71                       
    40 00000014 50                            push ax
    41                                        
    42                                        ;读入分 
    43 00000015 B002                          mov al,0x02
    44 00000017 E670                          out 0x70,al
    45 00000019 E471                          in al,0x71               
    46 0000001B 50                            push ax
    47                                  
    48                                        ;读入时 
    49 0000001C B004                          mov al,0x04
    50 0000001E E670                          out 0x70,al
    51 00000020 E471                          in al,0x71                     
    52 00000022 50                            push ax
    53                                             
    54                                        ;读取日
    55 00000023 B007                          mov al,0x07
    56 00000025 E670                          out 0x70,al
    57 00000027 E471                          in al,0x71
    58 00000029 50                            push ax 
    59                                  
    60                                        ;读取月
    61 0000002A B008                          mov al,0x08
    62 0000002C E670                          out 0x70,al
    63 0000002E E471                          in al,0x71
    64 00000030 50                            push ax 
    65                                            
    66                                        ;读取年
    67 00000031 B009                          mov al,0x09
    68 00000033 E670                          out 0x70,al
    69 00000035 E471                          in al,0x71
    70 00000037 50                            push ax
    71                                  ;=============================================================================; 
    72 00000038 B00C                          mov al,0x0c                        ;寄存器C的索引
    73 0000003A E670                          out 0x70,al
    74 0000003C E471                          in al,0x71                         ;读一下RTC的寄存器C，否则只发生一次中断
    75                                        
    76 0000003E B800B8                        mov ax,0xb800
    77 00000041 8EC0                          mov es,ax
    78                                        
    79 00000043 BBA007                        mov bx,12*160 + 16*2
    80 00000046 56                            push si
    81 00000047 51                            push cx
    82 00000048 BE[8D00]                      mov si,time_msg
    83 0000004B B91300                        mov cx,(data_end-time_msg)
    84                                  ShowMsg:
    85 0000004E 8A04                          mov al,[si]
    86 00000050 268807                        mov [es:bx],al
    87 00000053 46                            inc si
    88 00000054 83C302                        add bx,2
    89 00000057 E2F5                          loop ShowMsg 
    90 00000059 59                            pop cx 
    91 0000005A 5E                            pop si
    92                                        
    93                                  ;=============================================================================; 
    94 0000005B 58                            pop ax
    95 0000005C E88C00                        call bcd_to_ascii
    96 0000005F 268827                        mov [es:bx],ah
    97 00000062 26884702                      mov [es:bx+2],al                   ;显示两位年份 
    98 00000066 26C647042D                    mov byte [es:bx+4],'-'                   ;显示分隔符'-' 
    99                                  
   100 0000006B 58                            pop ax
   101 0000006C E87C00                        call bcd_to_ascii
   102 0000006F 26886706                      mov [es:bx+6],ah
   103 00000073 26884708                      mov [es:bx+8],al                   ;显示两位月份
   104 00000077 26C6470A2D                    mov byte [es:bx+10],'-'                  ;显示分隔符'-'
   105                                  
   106 0000007C 58                            pop ax
   107 0000007D E86B00                        call bcd_to_ascii
   108 00000080 2688670C                      mov [es:bx+12],ah
   109 00000084 2688470E                      mov [es:bx+14],al                  ;显示两位日期
   110                                  ;=============================================================================;    
   111 00000088 58                            pop ax
   112 00000089 E85F00                        call bcd_to_ascii
   113 0000008C 26886712                      mov [es:bx+18],ah
   114 00000090 26884714                      mov [es:bx+20],al                   ;显示两位小时   
   115 00000094 26C647163A                    mov byte [es:bx+22],':'                  ;显示分隔符':'
   116 00000099 26F65717                      not byte[es:bx+23]
   117                                        
   118 0000009D 58                            pop ax     
   119 0000009E E84A00                        call bcd_to_ascii
   120 000000A1 26886718                      mov [es:bx+24],ah
   121 000000A5 2688471A                      mov [es:bx+26],al                   ;显示两位分钟
   122 000000A9 26C6471C3A                    mov byte [es:bx+28],':'                  ;显示分隔符':'
   123 000000AE 26F6571D                      not byte[es:bx+29]
   124                                        
   125 000000B2 58                            pop ax
   126 000000B3 E83500                        call bcd_to_ascii
   127 000000B6 2688671E                      mov [es:bx+30],ah
   128 000000BA 26884720                      mov [es:bx+32],al                   ;显示两位秒
   129                                  ;=============================================================================;      
   130 000000BE 58                            pop ax
   131                                        ;call bcd_to_ascii
   132                                        ;sub al,'0'
   133 000000BF B409                          mov ah,9
   134 000000C1 F6E4                          mul ah
   135 000000C3 05[4E00]                      add ax,week_msg
   136 000000C6 83C324                        add bx,36
   137 000000C9 56                            push si
   138 000000CA 89C6                          mov si,ax
   139 000000CC 51                            push cx
   140 000000CD B90900                        mov cx,9
   141                                  ShowWeek:
   142 000000D0 8A04                          mov al,[si]
   143 000000D2 B40A                          mov ah,0x0a 
   144 000000D4 268907                        mov [es:bx],ax
   145 000000D7 46                            inc si
   146 000000D8 83C302                        add bx,2
   147 000000DB E2F3                          loop ShowWeek
   148 000000DD 59                            pop cx
   149 000000DE 5E                            pop si
   150                                  ;=============================================================================;
   151                                         
   152 000000DF B020                          mov al,0x20                        ;中断结束命令EOI 
   153 000000E1 E6A0                          out 0xa0,al                        ;向从片发送 
   154 000000E3 E620                          out 0x20,al                        ;向主片发送 
   155                                  
   156 000000E5 07                            pop es
   157 000000E6 5A                            pop dx
   158 000000E7 59                            pop cx
   159 000000E8 5B                            pop bx
   160 000000E9 58                            pop ax
   161                                  
   162 000000EA CF                            iret
   163                                  
   164                                  ;-------------------------------------------------------------------------------
   165                                  bcd_to_ascii:                            ;BCD码转ASCII
   166                                                                           ;输入：AL=bcd码
   167                                                                           ;输出：AX=ascii
   168 000000EB 88C4                          mov ah,al                          ;分拆成两个数字 
   169 000000ED 240F                          and al,0x0f                        ;仅保留低4位 
   170 000000EF 0430                          add al,0x30                        ;转换成ASCII 
   171                                  
   172 000000F1 C0EC04                        shr ah,4                           ;逻辑右移4位 
   173 000000F4 80E40F                        and ah,0x0f                        
   174 000000F7 80C430                        add ah,0x30
   175                                  
   176 000000FA C3                            ret
   177                                  
   178                                  ;-------------------------------------------------------------------------------
   179                                  start:
   180 000000FB A1[1400]                      mov ax,[stack_segment]
   181 000000FE 8ED0                          mov ss,ax                          ;设置堆栈段段寄存器
   182 00000100 BC[0001]                      mov sp,ss_pointer				     ;set stack point [sp]
   183 00000103 A1[1000]                      mov ax,[data_segment]
   184 00000106 8ED8                          mov ds,ax                          ;set ds
   185                                        
   186 00000108 BB[0000]                      mov bx,init_msg                    ;显示初始信息 init_msg:'starting...',0x0d,0x0a,0
   187 0000010B E84300                        call put_string
   188                                  
   189 0000010E BB[0E00]                      mov bx,inst_msg                    ;显示安装信息 
   190 00000111 E83D00                        call put_string
   191                                        
   192 00000114 B070                          mov al,0x70						 ;从片中断号从0x70开始,且第一个引脚就是实时时钟中断
   193 00000116 B304                          mov bl,4							 ;一个中断向量占4字节
   194 00000118 F6E3                          mul bl                             ;计算0x70号中断在IVT(中断向量表)中的偏移
   195 0000011A 89C3                          mov bx,ax                          ;0x0000:bx对应物理地址,存的就是0x70号中断的入口地址
   196                                  
   197 0000011C FA                            cli                                ;防止改动期间发生新的0x70号中断(关中断)
   198                                  
   199 0000011D 06                            push es							 ;backup es
   200 0000011E B80000                        mov ax,0x0000
   201 00000121 8EC0                          mov es,ax					
   202 00000123 26C707[0000]                  mov word [es:bx],new_int_0x70      ;设置0x70号中断的 中断处理程序 偏移地址。
   203                                                                            
   204 00000128 268C4F02                      mov word [es:bx+2],cs              ;设置0x70号中断的 中断处理程序 段(基)地址
   205 0000012C 07                            pop es
   206                                        ;中断向量表设置完成
   207                                  	  
   208                                  	  ;下面设置RTC工作状态
   209 0000012D B00B                          mov al,0x0b                        ;RTC寄存器B
   210                                        ;or al,0x80                         ;阻断NMI 将0x70端口高位置1（0x80=1000 0000B）
   211 0000012F E670                          out 0x70,al						 ;0X70最高位控制着NMI通行
   212                                  	  
   213 00000131 B012                          mov al,0x12                        ;设置寄存器{禁止周期性中断，关闹钟中断，开放更 
   214 00000133 E671                          out 0x71,al                        ;新结束后中断，BCD码，24小时制(0x12=0001 0010B)}
   215                                  	  ;读入RTC中断
   216 00000135 B00C                          mov al,0x0c
   217 00000137 E670                          out 0x70,al
   218 00000139 E471                          in al,0x71                         ;读RTC寄存器C，复位未决的中断状态（C寄存器清零）
   219                                  	  ;至此,对于RTC访问完毕，NMI已打开(0x0c=0000 1100B)
   220                                  	  
   221                                  	  ;修改从片中断屏蔽寄存器，位0为0，使之接受RTC中断(默认不接受)
   222 0000013B E4A1                          in al,0xa1                         ;读8259从片的IMR寄存器 0xa1 IMR端口
   223 0000013D 24FE                          and al,0xfe                        ;清除bit 0(此位连接RTC)
   224 0000013F E6A1                          out 0xa1,al                        ;写回此寄存器 
   225                                  
   226 00000141 FB                            sti                                ;重新开放中断 IF=1 
   227                                  
   228                                  	  ;-----------------------------------------
   229 00000142 BB[3000]                      mov bx,done_msg                    ;显示安装完成信息 
   230 00000145 E80900                        call put_string
   231                                  
   232 00000148 BB[3800]                      mov bx,tips_msg                    ;显示提示信息
   233 0000014B E80300                        call put_string
   234                                  
   235                                   .idle:
   236 0000014E F4                            hlt                                ;使CPU进入低功耗状态，直到用中断唤醒 
   237 0000014F EBFD                          jmp .idle
   238                                  
   239                                  ;-------------------------------------------------------------------------------
   240                                  put_string:                              ;显示串(0结尾)。
   241                                                                           ;输入：DS:BX=串地址
   242 00000151 8A0F                             mov cl,[bx]                     ;bx=init_msg 首地址
   243 00000153 08C9                             or cl,cl                        ;cl=0 ? //测试是否到字符串尾部
   244 00000155 7406                             jz .exit                        ;是的，返回主程序 
   245 00000157 E80400                           call put_char		
   246 0000015A 43                               inc bx                          ;下一个字符 
   247 0000015B EBF4                             jmp put_string
   248                                  
   249                                     .exit:
   250 0000015D C3                               ret
   251                                  
   252                                  ;-------------------------------------------------------------------------------
   253                                  put_char:                                ;显示一个字符
   254                                                                           ;输入：字符放在cl中
   255 0000015E 50                               push ax
   256 0000015F 53                               push bx
   257 00000160 51                               push cx
   258 00000161 52                               push dx
   259 00000162 1E                               push ds
   260 00000163 06                               push es						 ;寄存器备份
   261                                  
   262                                           ;以下取当前光标位置			 ;详见P142介绍
   263 00000164 BAD403                           mov dx,0x3d4                    ;显卡索引存储器端口,显卡Reg很多，通过索引寄存器间接访问
   264 00000167 B00E                             mov al,0x0e
   265 00000169 EE                               out dx,al						 ;向0x3d4端口发送索引0x0e(指定显卡中14号寄存器)
   266 0000016A BAD503                           mov dx,0x3d5					 ;从0x3d5端口读取数据
   267 0000016D EC                               in al,dx                        ;高8位（in操作目的操作数必须是AX或AL） 
   268 0000016E 88C4                             mov ah,al
   269                                  
   270 00000170 BAD403                           mov dx,0x3d4
   271 00000173 B00F                             mov al,0x0f					 ;指定显卡中15号寄存器（14 h8,15 l8）
   272 00000175 EE                               out dx,al
   273 00000176 BAD503                           mov dx,0x3d5
   274 00000179 EC                               in al,dx                        ;低8位 
   275 0000017A 89C3                             mov bx,ax                       ;BX=代表光标位置的16位数
   276                                  
   277 0000017C 80F90D                           cmp cl,0x0d                     ;回车符？
   278 0000017F 750C                             jnz .put_0a                     ;不是。看看是不是换行等字符
   279                                  		 ;以下计算回车目标位置(行首)
   280 00000181 89D8                             mov ax,bx                       ;当前光标位置做被除数
   281 00000183 B350                             mov bl,80                       
   282 00000185 F6F3                             div bl							 ;除以80得到行号al中（商）
   283 00000187 F6E3                             mul bl							 ;alx80就是当前行首的位置(存在AX中)
   284 00000189 89C3                             mov bx,ax						 ;送入BX保存
   285 0000018B EB45                             jmp .set_cursor
   286                                  
   287                                   .put_0a:
   288 0000018D 80F90A                           cmp cl,0x0a                     ;换行符？
   289 00000190 7505                             jnz .put_other                  ;不是，那就正常显示字符 
   290                                  		 ;以下换行
   291 00000192 83C350                           add bx,80						 ;光标位置+80跳到下一行该位置
   292 00000195 EB0F                             jmp .roll_screen
   293                                  
   294                                   .put_other:                             ;正常显示字符
   295 00000197 B800B8                           mov ax,0xb800
   296 0000019A 8EC0                             mov es,ax
   297 0000019C D1E3                             shl bx,1                        ;光标位置乘以2就是当前待显示字符的显存偏移
   298 0000019E 26880F                           mov [es:bx],cl                  ;使用默认颜色,每次通过x2计算偏移，颜色位置总会空出来
   299                                  
   300                                           ;以下将光标位置推进一个字符
   301 000001A1 D1EB                             shr bx,1                        ;复原光标位置
   302 000001A3 83C301                           add bx,1				
   303                                  
   304                                   .roll_screen:
   305 000001A6 81FBD007                         cmp bx,2000                     ;光标超出屏幕？滚屏
   306 000001AA 7C26                             jl .set_cursor
   307                                  		 ;以下>=2000字符，开始滚屏
   308 000001AC B800B8                           mov ax,0xb800
   309 000001AF 8ED8                             mov ds,ax
   310 000001B1 8EC0                             mov es,ax
   311 000001B3 FC                               cld                             ;方向标志位DF清0指令,为了movsw正向移动（l->h）
   312                                  		 ;以下的核心是将显存内容，从0xb800:160地址开始以后的1920*2个字节往前移动160个字节
   313                                  		 ;（即将下面24行内容都往上移动一行）
   314 000001B4 BEA000                           mov si,0xa0                     ;指定移动的源数据位于显存偏移160位置
   315 000001B7 BF0000                           mov di,0x00					 ;指定移动的目的地址位显存偏移0位置
   316 000001BA B98007                           mov cx,1920					 ;移动次数1920
   317 000001BD F3A5                             rep movsw						 ;每次移动一个字，重复1920次
   318 000001BF BB000F                           mov bx,3840                     ;清除屏幕最底一行;bx指向25行第一个字符处,从此处开始清空字符
   319 000001C2 B95000                           mov cx,80                       ;设置循环次数
   320                                   .cls:
   321 000001C5 26C7072007                       mov word[es:bx],0x0720          ;空白字符填充
   322 000001CA 83C302                           add bx,2
   323 000001CD E2F6                             loop .cls
   324                                  
   325 000001CF BB8007                           mov bx,1920					 ;光标重新置回25行行首
   326                                  	
   327                                           ;以上bx只是逻辑光标，下面真实设置光标
   328                                   .set_cursor:
   329 000001D2 BAD403                           mov dx,0x3d4					 ;0x3d4索引
   330 000001D5 B00E                             mov al,0x0e
   331 000001D7 EE                               out dx,al
   332 000001D8 BAD503                           mov dx,0x3d5                    ;0x3d5读写
   333 000001DB 88F8                             mov al,bh
   334 000001DD EE                               out dx,al                       ;写入高8位
   335                                  		 
   336 000001DE BAD403                           mov dx,0x3d4
   337 000001E1 B00F                             mov al,0x0f
   338 000001E3 EE                               out dx,al
   339 000001E4 BAD503                           mov dx,0x3d5
   340 000001E7 88D8                             mov al,bl
   341 000001E9 EE                               out dx,al                       ;写入低8位
   342                                  
   343 000001EA 07                               pop es
   344 000001EB 1F                               pop ds
   345 000001EC 5A                               pop dx
   346 000001ED 59                               pop cx
   347 000001EE 5B                               pop bx
   348 000001EF 58                               pop ax
   349                                  
   350 000001F0 C3                               ret
   351                                  
   352                                  ;===============================================================================
   353                                  SECTION data align=16 vstart=0
   354                                  
   355 00000000 5374617274696E672E-         init_msg       db 'Starting...',0x0d,0x0a,0 ;0x0d = 回车,0x0a = 换行 
   355 00000009 2E2E0D0A00         
   356                                  												;(回车就是回到行首,换行是换到下一行,来源于老式打字机)
   357 0000000E 496E7374616C6C696E-         inst_msg       db 'Installing a new interrupt 70H...',0
   357 00000017 672061206E65772069-
   357 00000020 6E7465727275707420-
   357 00000029 3730482E2E2E00     
   358                                      
   359 00000030 446F6E652E0D0A00            done_msg       db 'Done.',0x0d,0x0a,0
   360                                  
   361 00000038 436C6F636B20697320-         tips_msg       db 'Clock is now working.',0
   361 00000041 6E6F7720776F726B69-
   361 0000004A 6E672E00           
   362                                      
   363 0000004E 53756E646179202020-         week_msg       db 'Sunday   Monday   Tuesday  WednesdayThursday Friday   Saturday ' 
   363 00000057 4D6F6E646179202020-
   363 00000060 547565736461792020-
   363 00000069 5765646E6573646179-
   363 00000072 546875727364617920-
   363 0000007B 467269646179202020-
   363 00000084 536174757264617920 
   364                                      
   365 0000008D 4E6F772C7468652074-         time_msg       db 'Now,the time is: 20'
   365 00000096 696D652069733A2032-
   365 0000009F 30                 
   366                                  data_end:
   367                                                     
   368                                  ;===============================================================================
   369                                  SECTION stack align=16 vstart=0
   370                                             
   371 00000000 <res 00000100>                           resb 256
   371          ******************       warning: uninitialized space declared in stack section: zeroing
   372                                  ss_pointer:
   373                                   
   374                                  ;===============================================================================
   375                                  SECTION program_trail
   376                                  program_end:
